//
// collect modules generated by bazel build
//
#include "mediapipe/framework/subgraph.h"

//
// read graph config from .pbtxt
bool read_config_from_pbtxt(mediapipe::CalculatorGraphConfig& config, char const* filename) {
  bool result = false;
  FILE* file = fopen(filename, "rb");
  if (file) {
    fseek(file, 0, SEEK_END);
    auto const file_len = ftell(file);
    fseek(file, 0, SEEK_SET);
    char* buf = (char*) malloc(file_len);
    if (buf) {
      result = (file_len==fread(buf, 1, file_len, file)) &&
                google::protobuf::TextFormat::ParseFromString(std::string(buf, file_len), &config);
      free(buf);
    }
    fclose(file);
  }
  return result;
}

namespace mediapipe {

#define DEFINE_SUBGRAPH(class_name, pbtxt)                                           \
struct class_name : public Subgraph {                                                \
  absl::StatusOr<CalculatorGraphConfig> GetConfig(SubgraphOptions const&) override { \
    CalculatorGraphConfig config;                                                    \
    if (read_config_from_pbtxt(config, pbtxt)) {                                     \
      return config;                                                                 \
    }                                                                                \
    return absl::InternalError("Could not parse subgraph.");                         \
  }                                                                                  \
};                                                                                   \
REGISTER_MEDIAPIPE_GRAPH(class_name)


#if !MEDIAPIPE_DISABLE_GPU
DEFINE_SUBGRAPH(FaceLandmarkFrontGpu, "face_landmark_front_gpu.pbtxt");
DEFINE_SUBGRAPH(FaceLandmarkGpu, "face_landmark_gpu.pbtxt");
DEFINE_SUBGRAPH(FaceDetectionFrontGpu, "face_detection_front_gpu.pbtxt");
DEFINE_SUBGRAPH(FaceRendererGpu, "face_renderer_gpu.pbtxt");
#endif

DEFINE_SUBGRAPH(FaceLandmarkFrontCpu, "face_landmark_front_cpu.pbtxt");
DEFINE_SUBGRAPH(FaceDetectionShortRangeCpu, "face_detection_short_range_cpu.pbtxt");
DEFINE_SUBGRAPH(FaceDetectionFrontDetectionToRoi, "face_detection_front_detection_to_roi.pbtxt");
DEFINE_SUBGRAPH(FaceLandmarkCpu, "face_landmark_cpu.pbtxt");
DEFINE_SUBGRAPH(FaceLandmarkLandmarksToRoi, "face_landmark_landmarks_to_roi.pbtxt");
DEFINE_SUBGRAPH(FaceDetectionShortRangeCommon, "face_detection_short_range_common.pbtxt");
DEFINE_SUBGRAPH(FaceLandmarksModelLoader, "face_landmarks_model_loader.pbtxt");
DEFINE_SUBGRAPH(TensorsToFaceLandmarks, "tensors_to_face_landmarks.pbtxt");
DEFINE_SUBGRAPH(TensorsToFaceLandmarksWithAttention, "tensors_to_face_landmarks_with_attention.pbtxt");
DEFINE_SUBGRAPH(FaceGeometryFromLandmarks, "face_geometry_from_landmarks.pbtxt");
DEFINE_SUBGRAPH(FaceLandmarksSmoothing, "face_landmarks_smoothing.pbtxt");
DEFINE_SUBGRAPH(FaceRendererCpu, "face_renderer_cpu.pbtxt");

#if 0
// quick debug/test
struct FaceLandmarksSmoothing : public Subgraph {
  absl::StatusOr<CalculatorGraphConfig> GetConfig(SubgraphOptions const&) override {
    CalculatorGraphConfig config;
    if (read_config_from_pbtxt(config, "face_landmarks_smoothing.pbtxt")) {
      return config;
    }
    return absl::InternalError("Could not parse subgraph.");
  }
};
REGISTER_MEDIAPIPE_GRAPH(FaceLandmarksSmoothing);
#endif

}  // namespace mediapipe
